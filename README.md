## Конфигурационное управление практика №1 вариант №20

----

## Общее
- Графический интерфейс терминала, максимально похожий на настоящий терминал Linux
- Динамическое обновление строки приглашения ко вводу согласно текущей директории
- Виртуальная файловая система в формате `json`
- Поддержка `.sheesh` скриптов прямо в эмуляторе для имитации диалога с пользователем
----
## Поддерживаемые команды

- `help` - вывести список доступных комманд
- `clear` - очистить экран
- `exit` - закрыть эмулятор
- `echo` - вывести текст
- `ls` - перечислить файлы
- `cd` - сменить директорию
- `cat` - вывести содержимое файла
- `tac` - вывести содержимое файла в обратном порядке
- `wc` - вывести информацию о файле
    - флаг `-l`: вывод количества строк в файле
    - флаг `-w`: вывод количества слов в файле
    - флаг `-c`: вывод количества символов в файле
- `rm` - удалить файл или папку
    - флаг `-r`: удаление папки 
- Для запуска `.sheesh` скрипта достаточно написать в консоли `<имя_скрипта>.sheesh`
----
## Этап 1
1) Реализован графический интерфейс на Tkinter для эмулятора терминала Linux. Данные об имени пользователя и хоста берутся из реальной ОС.
2) Реализован парсер, разделяющий введенную строку на команду и массив аргументов.

----
## Этап 2
1) Физически VFS располагается в общей папке с кодом.
2) Стартовый скрипт `start.sheesh` выполняет все доступные команды и пропускает ошибочные строки. Выводится строка приглашения ко вводу, вводимая команда и результат работы команды.

----
## Этап 3
Создана файловая система в формате JSON, имеющая вид:
```json
{
 "name": "home",
 "children": [
    {
     "name": "hello.txt",
     "type": "file",
     "content": "SGVsbG8sIFdvcmxkIQ=="
    },
    {
     "name": "subfolder",
     "children": []
    }
 ]
}
```
Файлы имеют поле `"type": "file""`, что позволяет читать их содержимое, которое записано в base64 формате. Для первода любой строки в base64 был написан скрипт `encodeToBase64.py`
Для парсинга VFS и построения дерева файловой системы был написан класс `VFSBuilder.py`. Каждый узел представляет собой экземпляр класса `Node`, содержащий родительский узел, массив подчиненных узлов и содержимое, если это файл.

----
## Этап 4
### Реализация команды `ls`
Команда `ls` получает список подчиненных узлов у родительского узла текущей директории и выводит их имена.
### Реализация команды `cd`
При смене директории обновляется поле `current_directory`, отвечающее за текущую рабочую папку. Это удобно для реализации остальных команд, потому что мы имеем доступ к родительскому и подчиненным узлам. Также в строке приглашения ко вводу записывается рабочая директория.
1) Если не было передано аргументов, то происходит переход в коревую папку.
2) Если передан путь, то он разделяется на последовательность папок по символу `/`. После проверки существования пути происходит переход по цепочке в нужную папку.
### Реализация команды `cat`
Если указанный файл существует, то вызывается метод `readContent()` указанного узла, который декодирует строку в формате base64 и возвращает результат. Содержимое файла выводится напрямую в консоль.
### Реализация команды `tac`
Алгоритм похож на команду `cat`, но метод `readContent()` вывзывается с флагом `reverse`, который разделяет декодированную строку по символу `\n`, разворачивает полученный массив строк и склеивает его в одну строку. Полученная строка передается на вывод.
### Реализация команды `wc`
Если указанный файл существует, то подсчитывается количество строк, слов и символов в файле. При передаче флагов `-l`, `-w` или `-c` в консоль выводится число строк, слов или символов соответственно, а также название файла. Если не указан ни один флаг, то выводятся все свойства файла.

---
## Этап 5
### Реализация команды `rm`
Удаление файлов и папок осуществляется с помощью удаления связи между родительским и подчиненным узлом файловой системы. Узел удаляется из массива подчиненных текущей директории. Таким образом файл `vfs.json` не изменяется физически, что позволяет эмулятору сбрасываться к первоначальному состоянию после перезапуска.
1) Если с командой передан один аргумент, то проверяем, является ли он названием файла, подчиненного узлу текущей директории. Если да, то удаляем файл. 
2) Если единственный переданный аргумент это флаг `-r`, то удаляются все элементы, подчиненные текущей директории. При этом сама папка не удаляется.
3) Если в качестве аргументов передан флаг `-r` и название папки, то удаляется всё её содержимое, а также она сама.

